<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <title>黑杰克 - XTSGAMES</title>
    <meta charset="UTF-8" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/type-normal.css" />
    <style></style>
    <script src="/inori-functions.js"></script>
</head>

<body><div class="mainBody">
    <div class="title">
        <h1>黑杰克</h1>
    </div>
    <div class="navigation">
        <h6><a href="../">XTSGAMES.TOP</a> &gt; <strong>黑杰克</strong></h6>
    </div>
    <div class="content">
        <div id="welcome">
            <p><strong>欢迎来到 黑杰克 游戏!</strong></p>
            <p><strong>注意: XTSGAMES 的黑杰克游戏或许有一些不同。</strong>请看下列规则:</p>
            <p><strong>玩家</strong>和<strong>庄家</strong>各有 <strong>5 点生命值</strong>。每失败一局<strong>降低一点生命值</strong>。降低至 0 则<strong>游戏失败</strong>。</p>
            <p><strong>玩家</strong>和<strong>庄家</strong>将会在<strong>去掉大小王的 52 张扑克牌 (花色忽略)</strong> 中轮流抽牌。</p>
            <p>双方无法看到<strong>对方</strong>抽到的<strong>第一张牌</strong>，但可以看到后续的牌。</p>
            <p>当你的牌的点数大小之和<strong>大于 21</strong>时，就不能再抽牌。</p>
            <p>根据需要，玩家和庄家可以选择<strong>停牌</strong>。一方停牌后，另一方<strong>仍可选择继续抽牌</strong>。</p>
            <p>如果双方停牌时，点数之和都<strong>小于等于 21</strong>，则点数<strong>最接近 21</strong> 的一方获胜；</p>
            <p>如果有且仅有一方的点数之和<strong>大于 21</strong>，则<strong>小于等于 21</strong> 的一方获胜；</p>
            <p>如果双方的点数之和<strong>都大于 21</strong>或<strong>相等</strong>，则游戏平局。</p>
            <p>A 可视为 <strong>1 点或 11 点</strong>，如果 A 认为是 11 点时点数之和<strong>大于 21</strong>，则该 A 认为是 <strong>1 点</strong>。</p>
            <p>J, Q, K 均视为 <strong>10 点</strong>。</p>
            <br />
            <p><button onclick="start()">开始游戏</button></p>
            <br />
            <p>你会在每次抽牌时有 <strong>25%</strong> 的概率获得一个随机道具。</p>
            <p><strong>钢笔</strong> - 将点数上限从 21 改为 24</p>
            <p><strong>交换器</strong> - 将你的最后一张牌和庄家的最后一张牌互换</p>
            <p><strong>打火机</strong> - 移除你的最后一张牌</p>
            <p><strong>小刀</strong> - 如果这一局你胜利，则对庄家造成额外 1 点伤害 (不可叠加)</p>
            <p><strong>盾牌</strong> - 如果这一局你失败，抵挡 1 点伤害 (不可叠加)</p>
            <p><strong>桃</strong> - 回复 1 点生命值</p>
        </div>
        <div id="game" hide>
            <br />
            <h2>Round <span id="round" style="color: var(--aqua)">0</span></h2>
            <br />
            <h3>玩家 <span id="playerHealth"></span> <span id="playerKnife" style="color: var(--red)" hide>[↓]</span><span id="playerShield" style="color: var(--blue)" hide>[■]</span></h3>
            <p><strong id="playerLine"><span id="playerTotal" style="color: var(--blue)">0</span> : </strong></p>
            <br />
            <p><button id="drawButton" style="color: var(--green); border: 2px solid var(--green)" onclick="draw()">抽牌</button><strong style="color: var(--blue)">-<span id="currentTarget" style="color: var(--blue)">21</span>-</strong><button id="standButton" style="color: var(--red); border: 2px solid var(--red)" onclick="stand()">停牌</button><span id="status"></span></p>
            <br />
            <p><strong id="dealerLine"><span id="dealerTotal" style="color: var(--orange)">0</span> : </strong></p>
            <h3>庄家 <span id="dealerHealth"></span> <span id="dealerKnife" style="color: var(--red)" hide>[↑]</span><span id="dealerShield" style="color: var(--blue)" hide>[■]</span></h3>
            <br />
            <p id="propUsedEffects">&nbsp;</p>
            <br />
            <h3>我的道具</h3>
            <div id="propList">
                <p style="color: var(--gray)">空</p>
            </div>
        </div>
    </div>
    <script>
        const fullDeck = ["A", "A", "A", "A", "2", "2", "2", "2", "3", "3", "3", "3", "4", "4", "4", "4", "5", "5", "5", "5", "6", "6", "6", "6", "7", "7", "7", "7", "8", "8", "8", "8", "9", "9", "9", "9", "10", "10", "10", "10", "J", "J", "J", "J", "Q", "Q", "Q", "Q", "K", "K", "K", "K"];
        let currentDeck = fullDeck.isolate();
        let playerHand = [];
        let dealerHand = [];
        let round = 0;
        let targetPoint = 21;

        let playerTotal = 0;
        let dealerTotal = 0;
        let playerTotalWithoutA = 0;
        let dealerTotalWithoutA = 0;

        let dealerFirstDrawn = "";
        let standThreshold;

        let playerHealth = 5;
        let dealerHealth = 5;
        let playerTakingDamage = 1;
        let dealerTakingDamage = 1;

        let propID = 0;
        let dealerProps = [];
        let dealerPropThought = {
            pen: 0,
            exchanger: 0,
            lighter: 0,
            knife: 0,
            shield: 0,
            peach: 0
        };
        let dealerUsedPropThisTurn = false;

        function start() {
            fadeChange("welcome", "game");
            updateHealth();
            getThreshold();
            copyTo("round", ++round);
        }

        function draw() {
            const drawnCard = currentDeck[rand(0, currentDeck.length - 1)]; // "A"

            currentDeck = currentDeck.remove(drawnCard); // Remove the drawn card from deck
            playerHand.push(drawnCard); // Add it to player's hand
            addTo("playerLine", `${drawnCard} `);

            if (!isNaN(drawnCard)) { // 2 ~ 10 is drawn
                playerTotalWithoutA += parseInt(drawnCard);
            } else if (drawnCard != "A") { // J, Q, K is drawn
                playerTotalWithoutA += 10;
            }
            checkA(); // If A is drawn, check value here
            updateTotal();
            drawStatus(false);
            if (chance(0.25)) { getProp(); }

            if (!copyFrom("dealerLine").includes("已停牌")) {
                dealerAct();
            } else {
                drawStatus(playerTotal > targetPoint ? false : true);
            }
        }

        function checkA() {
            const playerAs = playerHand.toString().getCountOf("A");
            const dealerAs = dealerHand.toString().getCountOf("A");

            if (playerAs >= 1) { // If has A?
                if (playerTotalWithoutA <= targetPoint - 11) { // < 11, one A consider as 11, others 1
                    playerTotal = playerTotalWithoutA + 11 + playerAs - 1;
                } else { // > 10, all A consider as 1
                    playerTotal = playerTotalWithoutA + playerAs;
                }
            } else {
                playerTotal = playerTotalWithoutA;
            }

            if (dealerAs >= 1) {
                if (dealerTotalWithoutA <= targetPoint - 11) { // < 11, one A consider as 11, others 1
                    dealerTotal = dealerTotalWithoutA + 11 + dealerAs - 1;
                } else { // > 10, all A consider as 1
                    dealerTotal = dealerTotalWithoutA + dealerAs;
                }
            } else {
                dealerTotal = dealerTotalWithoutA;
            }
        }

        function updateTotal() {
            copyTo("playerTotal", playerTotal);
            copyTo("dealerTotal", `${getDealerTotalLine()}`);

            repaint();
            drawStatus(false);
        }

        function getDealerTotal() {
            if (copyFrom("dealerLine").indexOf("[?]") >= 0) {
                const checkArray = dealerHand.slice(1);
                let counter = 0;

                checkArray.forEach(card => {
                    if (counter != "?") {
                        if (!isNaN(card)) {
                            counter += parseInt(card);
                        } else if (card != "A") {
                            counter += 10;
                        } else {
                            counter = "?";
                        }
                    }
                });

                return counter;
            } else { // Exchanger Used
                return dealerTotal;
            }
        }

        function getDealerTotalLine() {
            if (copyFrom("dealerLine").indexOf("[?]") >= 0) {
                if (dealerTotal == 0) {
                    return "0";
                }
                if (getDealerTotal() == 0) {
                    return "?";
                } else {
                    return `?+${getDealerTotal()}`;
                }
            } else {
                return getDealerTotal();
            }
        }

        function drawStatus(boolean) {
            if (boolean) {
                target("drawButton").disabled = false;
                styleTo("drawButton", "color: var(--green); border: 2px solid var(--green);");
            } else {
                target("drawButton").disabled = true;
                styleTo("drawButton", "color: var(--gray); border: 2px solid var(--gray);");
            }
        }

        function standStatus(boolean) {
            const propButtons = query(".propButton");

            target("standButton").disabled = !boolean;
            if (boolean) {
                styleTo("standButton", "color: var(--red); border: 2px solid var(--red);");
            } else {
                styleTo("standButton", "color: var(--gray); border: 2px solid var(--gray);");
            }

            for (let i = 0; i < propButtons.length; i++) {
                propButtons[i].disabled = !boolean;
            }
        }

        async function dealerAct() {
            standStatus(false);
            copyTo("status", "庄家思考中...");
            colorTo("status", "var(--aqua)");

            await sleep(rand(500, 1000));
            dealerThinkProp();

            if (dealerTotal < standThreshold) {
                await sleep(rand(1000, 3000));
                dealerDraw();
            }

            if (dealerTotal >= standThreshold) {
                addTo("dealerLine", "<span style='color: var(--red)'>已停牌</span>");
            }

            drawStatus(playerTotal > targetPoint ? false : true);
            standStatus(true);
            copyTo("status", "");
            dealerUsedPropThisTurn = false;
        }

        function dealerDraw() {
            const drawnCard = currentDeck[rand(0, currentDeck.length - 1)];

            currentDeck = currentDeck.remove(drawnCard);
            dealerHand.push(drawnCard);
            if (dealerTotal == 0) {
                addTo("dealerLine", `[?] `);
                dealerFirstDrawn = drawnCard;
            } else {
                addTo("dealerLine", `${drawnCard} `);
            }

            if (!isNaN(drawnCard)) {
                dealerTotalWithoutA += parseInt(drawnCard);
            } else if (drawnCard != "A") {
                dealerTotalWithoutA += 10;
            }
            checkA();
            updateTotal();
            if (chance(0.25)) { dealerGetProp(); }
        }

        function getThreshold() {
            standThreshold = rand(targetPoint - 6, targetPoint - 3);
        }

        function updateHealth() {
            const heartFull = "<span style='color: var(--lightRed)'>■</span>";
            const heartEmpty = "<span style='color: var(--gray)'>■</span>";

            playerHealth = playerHealth.toRange(0, 5);
            dealerHealth = dealerHealth.toRange(0, 5);

            copyTo("playerHealth", "");
            copyTo("dealerHealth", "");

            for (let i = 1; i <= playerHealth; i++) {
                addTo("playerHealth", heartFull);
            }
            for (let i = 1; i <= 5 - playerHealth; i++) {
                addTo("playerHealth", heartEmpty);
            }
            for (let i = 1; i <= dealerHealth; i++) {
                addTo("dealerHealth", heartFull);
            }
            for (let i = 1; i <= 5 - dealerHealth; i++) {
                addTo("dealerHealth", heartEmpty);
            }
        }

        function stand() {
            drawStatus(false);
            standStatus(false);
            addTo("playerLine", "<span style='color: var(--red)'>已停牌</span>");

            if (dealerTotal < standThreshold) {
                dealerActAfterPlayerStand();
            } else {
                result();
            }
        }

        async function dealerActAfterPlayerStand() {
            copyTo("status", "庄家思考中...");
            colorTo("status", "var(--aqua)");

            await sleep(rand(500, 1000));
            dealerThinkProp();

            await sleep(rand(1000, 2000));
            dealerDraw();
            
            if (dealerTotal >= standThreshold) {
                await sleep(rand(500, 1000));
                dealerThinkProp();
                addTo("dealerLine", "<span style='color: var(--red)'>已停牌</span>");

                result();
            } else {
                dealerActAfterPlayerStand();
            }
        }

        async function result() {
            copyTo("status", "结算中...");
            colorTo("status", "var(--blue)");
            dealerUsedPropThisTurn = false;
            await sleep(rand(2000, 3000));

            copyTo("dealerTotal", dealerTotal);
            copyTo("dealerLine", `${copyFrom("dealerLine").replace(/\[\?\]/, dealerFirstDrawn)}`);

            if (dealerTotal < targetPoint) {
                colorTo("dealerTotal", "var(--blue)");
            } else if (dealerTotal == targetPoint) {
                colorTo("dealerTotal", "var(--green)");
            } else {
                colorTo("dealerTotal", "var(--red)");
            }

            if (playerTotal <= targetPoint && dealerTotal <= targetPoint && playerTotal != dealerTotal) {
                if (playerTotal > dealerTotal) {
                    copyTo("status", "<strong>你赢了!</strong>");
                    colorTo("status", "var(--yellow)");
                    dealerHealth -= dealerTakingDamage;
                } else {
                    copyTo("status", "<strong>你输了!</strong>");
                    colorTo("status", "var(--red)");
                    playerHealth -= playerTakingDamage;
                }
            }
            if (playerTotal > targetPoint && dealerTotal <= targetPoint || playerTotal <= targetPoint && dealerTotal > targetPoint) {
                if (playerTotal > targetPoint) {
                    copyTo("status", "<strong>你输了!</strong>");
                    colorTo("status", "var(--red)");
                    playerHealth -= playerTakingDamage;
                } else {
                    copyTo("status", "<strong>你赢了!</strong>");
                    colorTo("status", "var(--yellow)");
                    dealerHealth -= dealerTakingDamage;
                }
            }
            if (playerTotal == dealerTotal || playerTotal > targetPoint && dealerTotal > targetPoint) {
                copyTo("status", "平局");
                colorTo("status", "var(--textColor-500)");
            }

            await sleep(3000);
            updateHealth();

            if (playerHealth == 0) {
                win(0);
            } else if (dealerHealth == 0) {
                win(1);
            } else {
                nextRound();
            }
        }

        function nextRound() {
            getThreshold();
            drawStatus(true);
            standStatus(true);

            currentDeck = fullDeck.isolate();
            playerHand = [];
            dealerHand = [];

            playerTotal = 0;
            dealerTotal = 0;
            playerTotalWithoutA = 0;
            dealerTotalWithoutA = 0;

            dealerFirstDrawn = "";

            playerTakingDamage = 1;
            dealerTakingDamage = 1;
            targetPoint = 21;

            copyTo("playerLine", `<span id="playerTotal" style="color: var(--blue)">0</span> : </strong>`);
            copyTo("dealerLine", `<span id="dealerTotal" style="color: var(--orange)">0</span> : </strong>`);
            copyTo("currentTarget", 21);
            hide("playerKnife");
            hide("playerShield");
            hide("dealerKnife");
            hide("dealerShield");
            copyTo("status", "");
            copyTo("round", ++round);
        }

        function win(who) {
            if (who == 0) { // Dealer Win
                copyTo("status", "<strong>庄家胜利!</strong>");
                colorTo("status", "var(--red)");
            } else { // Player Win
                copyTo("status", "<strong>玩家胜利!</strong>");
                colorTo("status", "var(--yellow)");
            }
        }

        function getProp() {
            const d = rand(1, 6);

            if (copyFrom("propList").includes("空")) {
                copyTo("propList", "");
            }

            if (d == 1) { // Pen
                addTo("propList", `<p id="propLine${++propID}"><strong>钢笔</strong><button class="propButton" onclick="useProp(${propID})">使用</button>- 将点数上限从 21 改为 24</p>`);
            }
            if (d == 2) { // Exchanger
                addTo("propList", `<p id="propLine${++propID}"><strong>交换器</strong><button class="propButton" onclick="useProp(${propID})">使用</button>- 将你的最后一张牌和庄家的最后一张牌互换</p>`);
            }
            if (d == 3) { // Lighter
                addTo("propList", `<p id="propLine${++propID}"><strong>打火机</strong><button class="propButton" onclick="useProp(${propID})">使用</button>- 移除你的最后一张牌</p>`);
            }
            if (d == 4) { // Knife
                addTo("propList", `<p id="propLine${++propID}"><strong>小刀</strong><button class="propButton" onclick="useProp(${propID})">使用</button>- 如果这一局你胜利，则对庄家造成额外 1 点伤害</p>`);
            }
            if (d == 5) { // Shield
                addTo("propList", `<p id="propLine${++propID}"><strong>盾牌</strong><button class="propButton" onclick="useProp(${propID})">使用</button>- 如果这一局你失败，抵挡 1 点伤害</p>`);
            }
            if (d == 6) { // Peach
                addTo("propList", `<p id="propLine${++propID}"><strong>桃</strong><button class="propButton" onclick="useProp(${propID})">使用</button>- 回复 1 点生命值</p>`);
            }
        }

        async function useProp(id) {
            const prop = copyFrom(`propLine${id}`);

            target(`propLine${id}`).remove();
            unhide("propUsedEffects");
            colorTo("propUsedEffects", "var(--blue)");

            if (prop.includes("钢笔")) {
                targetPoint = 24;
                copyTo("currentTarget", 24);
                repaint();
                if (playerTotal <= 21) { drawStatus(true); }

                copyTo("propUsedEffects", "玩家 使用 钢笔: 点数上限从 21 改为 24");
            }
            if (prop.includes("交换器")) {
                if (playerHand.length != 0 && dealerHand.length != 0) {
                    const playerLast = playerHand[playerHand.length - 1];
                    const dealerLast = dealerHand[dealerHand.length - 1];
                    
                    playerHand[playerHand.length - 1] = dealerLast;
                    dealerHand[dealerHand.length - 1] = playerLast;
                    copyTo("playerLine", copyFrom("playerLine").replace(/[^ ]* $/, `${dealerLast} `));
                    copyTo("dealerLine", copyFrom("dealerLine").replace(/[^ ]* (<span style="color: var\(--red\)">已停牌<\/span>)?$/, `${playerLast} $1`));

                    playerTotalWithoutA = valuationHandWithoutA(playerHand);
                    dealerTotalWithoutA = valuationHandWithoutA(dealerHand);

                    checkA();
                    updateTotal();
                    if (playerTotal <= 21) { drawStatus(true); }

                    copyTo("propUsedEffects", "玩家 使用 交换器: 你的最后一张牌和庄家的最后一张牌互换");
                } else {
                    copyTo("propUsedEffects", "玩家 使用 交换器: 你的最后一张牌和庄家的最后一张牌互换 <strong style='color: var(--red)'>(没有可移除的内容)</strong>");
                }
            }
            if (prop.includes("打火机")) {
                if (playerHand.length != 0) {
                    playerHand.pop();
                    copyTo("playerLine", copyFrom("playerLine").replace(/[^ ]* $/, ""));

                    playerTotalWithoutA = valuationHandWithoutA(playerHand);
                    checkA();
                    updateTotal();
                    if (playerTotal <= 21) { drawStatus(true); }

                    copyTo("propUsedEffects", "玩家 使用 打火机: 移除你的最后一张牌");
                } else {
                    copyTo("propUsedEffects", "玩家 使用 打火机: 移除你的最后一张牌 <strong style='color: var(--red)'>(没有可移除的内容)</strong>");
                }

            }
            if (prop.includes("小刀")) {
                if (isHidden("dealerShield")) {
                    dealerTakingDamage = 2;
                } else {
                    dealerTakingDamage = 1;
                }
                unhide("playerKnife", "inline");

                copyTo("propUsedEffects", "玩家 使用 小刀: 如果这一局你胜利，则对庄家造成额外 1 点伤害");
            }
            if (prop.includes("盾牌")) {
                if (isHidden("dealerKnife")) {
                    playerTakingDamage = 0;
                } else {
                    playerTakingDamage = 1;
                }
                unhide("playerShield", "inline");

                copyTo("propUsedEffects", "玩家 使用 盾牌: 如果这一局你失败，抵挡 1 点伤害");
            }
            if (prop.includes("桃")) {
                playerHealth = (++playerHealth).toRange(0, 5);
                updateHealth();

                copyTo("propUsedEffects", "玩家 使用 桃: 回复 1 点生命值");
            }
    
            if (copyFrom("propList") == "") {
                copyTo("propList", '<p style="color: var(--gray)">空</p>');
            }

            await sleep(1000);
            fadeOut("propUsedEffects", true);
        }

        function repaint() {
            if (playerTotal < targetPoint) {
                colorTo("playerTotal", "var(--blue)");
            } else if (playerTotal == targetPoint) {
                colorTo("playerTotal", "var(--green)");
            } else {
                colorTo("playerTotal", "var(--red)");
            }

            if (copyFrom("dealerLine").indexOf("[?]") >= 0 || dealerTotal == 0) {
                    colorTo("dealerTotal", "var(--orange)");
            } else {
                if (dealerTotal < targetPoint) {
                    colorTo("dealerTotal", "var(--blue)");
                } else if (dealerTotal == targetPoint) {
                    colorTo("dealerTotal", "var(--green)");
                } else {
                    colorTo("dealerTotal", "var(--red)");
                }
            }
        }

        function valuationHandWithoutA(arr) { // ["2", "A", "K"]
            let returnArray = [];
            let sum = 0;

            arr.filter(card => card != "A").forEach(card => {
                if (card == "J" || card == "Q" || card == "K") { card = "10"; }
                returnArray.push(+card);
            }); // [2, 10]

            returnArray.forEach(card => {
                sum += card;
            }); // 12

            return sum;
        }

        async function dealerUseProp(prop) {
            if (dealerUsedPropThisTurn) { // If dealer tried to use many props in a turn, give space time to show every hint
                await sleep(1020);
            }
            unhide("propUsedEffects");
            colorTo("propUsedEffects", "var(--red)");

            if (prop == 1) {
                targetPoint = 24;
                copyTo("currentTarget", 24);
                repaint();
                if (playerTotal <= 21 && !copyFrom("playerLine").indexOf("已停牌")) { drawStatus(true); }
        
                dealerProps = dealerProps.remove("Pen");
                copyTo("propUsedEffects", "庄家 使用 钢笔: 点数上限从 21 改为 24");
            }
            if (prop == 2) {
                const playerLast = playerHand[playerHand.length - 1];
                const dealerLast = dealerHand[dealerHand.length - 1];

                playerHand[playerHand.length - 1] = dealerLast;
                dealerHand[dealerHand.length - 1] = playerLast;
                copyTo("playerLine", copyFrom("playerLine").replace(/[^ ]* (<span style="color: var\(--red\)">已停牌<\/span>)?$/, `${dealerLast} $1`));
                copyTo("dealerLine", copyFrom("dealerLine").replace(/[^ ]* $/, `${playerLast} `));

                playerTotalWithoutA = valuationHandWithoutA(playerHand);
                dealerTotalWithoutA = valuationHandWithoutA(dealerHand);

                checkA();
                updateTotal();

                dealerProps = dealerProps.remove("Exchanger");
                copyTo("propUsedEffects", "庄家 使用 交换器: 庄家的最后一张牌和玩家的最后一张牌互换");
            }
            if (prop == 3) {
                if (dealerHand.length != 0) {
                    dealerHand.pop();
                    copyTo("dealerLine", copyFrom("dealerLine").replace(/[^ ]* $/, ""));

                    dealerTotalWithoutA = valuationHandWithoutA(dealerHand);
                    checkA();
                    updateTotal();

                    copyTo("propUsedEffects", "庄家 使用 打火机: 移除庄家的最后一张牌");
                } else {
                    copyTo("propUsedEffects", "庄家 使用 打火机: 移除庄家的最后一张牌 <strong style='color: var(--red)'>(没有可移除的内容)</strong>");
                }
                dealerProps = dealerProps.remove("Lighter");
            }
            if (prop == 4) {
                if (isHidden("playerShield")) {
                    playerTakingDamage = 2;
                } else {
                    playerTakingDamage = 1;
                }
                unhide("dealerKnife", "inline");

                dealerProps = dealerProps.remove("Knife");
                copyTo("propUsedEffects", "庄家 使用 小刀: 如果这一局庄家胜利，则对玩家造成额外 1 点伤害");
            }
            if (prop == 5) {
                if (isHidden("playerKnife")) {
                    dealerTakingDamage = 0;
                } else {
                    dealerTakingDamage = 1;
                }
                unhide("dealerShield", "inline");

                dealerProps = dealerProps.remove("Shield");
                copyTo("propUsedEffects", "庄家 使用 盾牌: 如果这一局庄家失败，抵挡 1 点伤害");
            }
            if (prop == 6) {
                dealerHealth = (++dealerHealth).toRange(0, 5);
                updateHealth();

                dealerProps = dealerProps.remove("Peach");
                copyTo("propUsedEffects", "庄家 使用 桃: 回复 1 点生命值");
            }

            dealerUsedPropThisTurn = true;
            await sleep(2000);
            fadeOut("propUsedEffects", true);
        }

        function dealerGetProp() {
            const d = rand(1, 6);

            if (d == 1) { dealerProps.push("Pen"); }
            if (d == 2) { dealerProps.push("Exchanger"); }
            if (d == 3) { dealerProps.push("Lighter"); }
            if (d == 4) { dealerProps.push("Knife"); }
            if (d == 5) { dealerProps.push("Shield"); }
            if (d == 6) { dealerProps.push("Peach"); }
        }

        function dealerThinkProp() {
            dealerPropThought = {
                pen: 0,
                exchanger: 0,
                lighter: 0,
                knife: 0,
                shield: 0,
                peach: 0
            };

            const dealerSeePlayerHand = playerHand.slice(1, playerHand.length); // 1st card excluded
            const dealerSeePlayerValue = valuationHandWithoutA(dealerSeePlayerHand);
            const dealerSeePlayerA = dealerSeePlayerHand.toString().getCountOf("A");
            const dealerSeePlayerMax = dealerSeePlayerValue + dealerSeePlayerA * 11 + 7;
            const dealerSeePlayerMin = dealerSeePlayerValue + dealerSeePlayerA + 7;

            let closestPossibility;
            if (Math.abs(dealerSeePlayerMax - targetPoint) >= Math.abs(dealerSeePlayerMin - targetPoint)) {
                closestPossibility = dealerSeePlayerMin;
            } else {
                closestPossibility = dealerSeePlayerMax;
            }

            // Dealer AI

            // Pen Thoughts
            if (closestPossibility >= targetPoint - 3 && closestPossibility <= targetPoint) { // Player near 21
                dealerPropThought.pen -= ((closestPossibility - (targetPoint - 3)) / 3).transit(0.3, 0.6);
            }
            if (dealerTotal == 21) { // Dealer is 21
                dealerPropThought.pen -= 1000;
            }
            if (dealerTotal >= 22 && dealerTotal <= 24 && targetPoint == 21) { // Dealer over 21
                dealerPropThought.pen += ((dealerTotal - 22) / 2).transit(0.8, 1);
            }

            if (targetPoint == 24) { dealerPropThought.pen = 0; } // Already target 24, don't waste

            // Exchanger Thoughts
            if (playerHand.length >= 2) { // Last card of player is known
                dealerPropThought.exchanger += 0.2; // Random exchange
                const afterExchange = valuationHandWithoutA(dealerHand) + dealerHand.toString().getCountOf("A") + playerHand[playerHand.length - 1]; // If exchange, the value of dealer's
                if (afterExchange >= 16 && afterExchange <= 21) { // Exchange gets a good value
                    dealerPropThought.exchanger += ((afterExchange - 18) / 3).transit(0.4, 1);
                }
                if (afterExchange <= 21 && dealerTotal >= 22) { // Exchange reduces hand
                    dealerPropThought.exchanger += 0.8;
                }
            } else { // Last card of player is unknown
                dealerPropThought.exchanger += 0.1;
            }
            if (dealerTotal == 21) { // Just 21, don't exchange
                dealerPropThought.exchanger -= 1000;
            }

            // Lighter Thoughts
            if (dealerTotal >= 15 && dealerTotal <= 20) { // Near 21, burn a card and try again
                dealerPropThought.lighter += ((dealerTotal - 17) / 3).transit(0.4, 0);
            }
            if (dealerTotal == 21) { // Just 21, don't burn
                dealerPropThought.lighter -= 1000;
            }
            if (dealerTotal >= 22 && dealerTotal <= 24) { // Over 21, burn if not using a pen
                dealerPropThought.lighter = 1 - dealerPropThought.pen;
            }
            if (dealerTotal >= 25) { // Over 24, burn immediately
                dealerPropThought.lighter += 1000;
            }

            // Knife Thoughts
            if (closestPossibility >= targetPoint) { // Player over the target
                dealerPropThought.knife += 0.5;
            }
            if (dealerTotal >= 17 && dealerTotal <= 20) { // Dealer near 21
                dealerPropThought.knife += ((dealerTotal - 17) / 3).transit(0.2, 0.9);
            }
            if (dealerTotal == 21) { // Dealer is 21
                dealerPropThought.knife += 1;
            }
            if (dealerTotal >= 22) { // Dealer over 21
                dealerPropThought.knife -= 1000;
            }
            if (isHidden("dealerKnife")) { // Dealer already have Knife
                dealerPropThought.knife -= 1000;
            }

            // Shield Thoughts
            if (closestPossibility >= targetPoint - 3 && closestPossibility <= targetPoint) { // Player near target
                dealerPropThought.shield += ((closestPossibility - 16) / 8).transit(0.1, 0.7);
            }
            if (closestPossibility >= targetPoint) { // Player might over target
                dealerPropThought.shield -= ((closestPossibility - targetPoint) / 4).transit(0.1, 0.4);
            }
            if (dealerTotal >= 13 && dealerTotal <= 17) { // Dealer is less
                dealerPropThought.shield += 0.3;
            }
            if (dealerTotal >= 18 && dealerTotal <= 20) { // Dealer is near 21
                dealerPropThought.shield -= 0.2;
            }
            if (dealerTotal == 21) { // Dealer is 21
                dealerPropThought.shield -= 1000;
            }
            if (dealerTotal >= 22) { // Dealer over 21
                dealerPropThought.shield += 0.3;
            }
            if (isHidden("dealerShield")) { // Dealer already have Shield
                dealerPropThought.shield -= 1000;
            }

            // Peach Thoughts
            if (dealerHealth <= 4) { // Dealer health is not full
                dealerPropThought.peach += ((dealerHealth - 1) / 3).transit(1, 0.4);
            }

            if (dealerProps.indexOf("Pen") >= 0 && chance(dealerPropThought.pen)) { dealerUseProp(1); }
            if (dealerProps.indexOf("Exchanger") >= 0 && chance(dealerPropThought.exchanger)) { dealerUseProp(2); }
            if (dealerProps.indexOf("Lighter") >= 0 && chance(dealerPropThought.lighter)) { dealerUseProp(3); }
            if (dealerProps.indexOf("Knife") >= 0 && chance(dealerPropThought.knife)) { dealerUseProp(4); }
            if (dealerProps.indexOf("Shield") >= 0 && chance(dealerPropThought.shield)) { dealerUseProp(5); }
            if (dealerProps.indexOf("Peach") >= 0 && chance(dealerPropThought.peach)) { dealerUseProp(6); }
        }
    </script>
</div></body>

</html>