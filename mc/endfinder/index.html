<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <title>Minecraft 要塞三角定位器 - ChiwaInori.top</title>
    <meta charset="UTF-8" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/type-normal.css" />
    <style>
        input {
            width: 64px;
        }

        .err {
            color: var(--red);
        }
    </style>
    <script src="/chiwa-functions.js"></script>
</head>

<body><div id="cw-main">
    <div id="cw-title">
        <h1>Minecraft 要塞三角定位器</h1>
    </div>
    <div id="cw-nav">
        <h6><a href="../../">ChiwaInori.top</a> &gt; <a href="../">Minecraft</a> &gt; <strong>Minecraft 末地传送门查找器</strong></h6>

    </div>
    <div id="cw-content">
        <p>在两个不同的位置投出末影之眼，并输入投掷时的位置和末影之眼飞行的方向 (或在游戏中按下 <strong>F3 + C</strong> 并选择 &quot;从剪切板中读取&quot; <span style="font-size: 10px;">(1.13 18w11a 及以上)</span>), 据此对要塞进行三角定位。</p>
        <p>要尽力减小人为误差，我们推荐使用 <strong>OptiFine 的放大功能</strong>，并将准星对准空中的末影之眼的垂直中心线 (不必对准水平中心线).</p>
        <br />
        <h4>#1 第一个投掷点</h4>
        <p><strong>X<input id="x1" /> Z<input id="z1" /> R<input id="r1" style="margin-right: 0px;" />°&nbsp;&nbsp;&nbsp;&nbsp;<button onclick="copy(1)">从剪切板中读取</button></strong> <span id="err1" class="err" hidden>读取时发生错误，请检查剪切板。</span></p>
        <br />
        <h4>#2 第二个投掷点 (你的当前位置)</h4>
        <p><strong>X<input id="x2" /> Z<input id="z2" /> R<input id="r2" style="margin-right: 0px;" />°&nbsp;&nbsp;&nbsp;&nbsp;<button onclick="copy(2)">从剪切板中读取</button></strong> <span id="err2" class="err" hidden>读取时发生错误，请检查剪切板。</span></p>
        <br />
        <button onclick="cal()">查找</button>
        <br /><br />
        <div id="result"></div>
        <br />
        <p class="ANT">此工具给出的可信度仅供定性参考，不代表你能在该坐标下找到要塞的实际概率。可信度的计算以你能够将对准末影之眼的角度控制在 ± 0.1° 以内的前提 (末影之眼飞到最高位置时，误差 1 个像素以内)。如果你的测量误差较大，请降低本工具给出的可信度。<a href="./index_old.html">使用旧版定位器...</a></p>
    </div>
    <script>
        const DEBUG = false;
        const DEBUG_COORD = [-5019.21, -9999.9, -102.94, -5014.6, -9965.87, -104.54];

        async function copy(ord) {
            try {
                const clip = await navigator.clipboard.readText();
                const coord = clip.match(/@s (.*)/)[1].split(" ");
                const [x, z, r] = [Number(coord[0]), Number(coord[2]), Number(coord[3])];
                cw(`#x${ord}`).value = x;
                cw(`#z${ord}`).value = z;
                cw(`#r${ord}`).value = r;
                checkAvailability();
            } catch (e) {
                cw(`#err${ord}`).unhide("inline");
                throw e;
            }
        }

        function checkAvailability() {
            cw(`#err1`).hide();
            cw(`#err2`).hide();

            cw("button", 2).disabled = !DEBUG && (cw("#x1").value == "" || cw("#z1").value == "" || cw("#r1").value == "" || cw("#x2").value == "" || cw("#z2").value == "" || cw("#r2").value == "");
        }
        checkAvailability();

        cw("#x1").event("input", checkAvailability);
        cw("#z1").event("input", checkAvailability);
        cw("#r1").event("input", checkAvailability);
        cw("#x2").event("input", checkAvailability);
        cw("#z2").event("input", checkAvailability);
        cw("#r2").event("input", checkAvailability);

        function cal() {
            const x1 = DEBUG ? DEBUG_COORD[0] : Number(cw("#x1").value);
            const z1 = DEBUG ? DEBUG_COORD[1] : Number(cw("#z1").value);
            const r1 = DEBUG ? DEBUG_COORD[2] : Number(cw("#r1").value);
            const x2 = DEBUG ? DEBUG_COORD[3] : Number(cw("#x2").value);
            const z2 = DEBUG ? DEBUG_COORD[4] : Number(cw("#z2").value);
            const r2 = DEBUG ? DEBUG_COORD[5] : Number(cw("#r2").value);

            log({ x1, z1, r1, x2, z2, r2 });

            // Convert degrees to radians
            const rad1 = r1 / 180 * Math.PI; //                                       O --------- > x
            const rad2 = r2 / 180 * Math.PI; //                                        |
            // Angle of line in xOz                                                           |
            const theta1 = rad1 + Math.PI / 2; // !                                  V
            const theta2 = rad2 + Math.PI / 2; // !                                  z

            //  Ax + Bz + C = 0
            // [A,     B,    C]
            const eq1 = [];
            const eq2 = [];
            eq1[0] = Math.sin(theta1);
            eq1[1] = -Math.cos(theta1);
            eq1[2] = z1 * Math.cos(theta1) - x1 * Math.sin(theta1);
            eq2[0] = Math.sin(theta2);
            eq2[1] = -Math.cos(theta2);
            eq2[2] = z2 * Math.cos(theta2) - x2 * Math.sin(theta2);

            log({ eq1, eq2 });

            // Distance to origin (player)
            const d1 = Math.sqrt(x1 ** 2 + z1 ** 2);
            const d2 = Math.sqrt(x2 ** 2 + z2 ** 2);
            const dPlayerOrigin = Math.max(d1, d2);

            // Results
            cw("#result").html = "";

            if (dPlayerOrigin >= 5e4) {
                cw("#result").html += `<h5>如果你正在游玩 Java 版: <span style="color: var(--red);">要塞会刷新在距离世界原点 24320 格的范围内</span> (1.9 版本以下则是约 1200 格内). 你距离世界原点 ${dPlayerOrigin.keep(0)} 格，远超出要塞的刷新位置。在这里进行定位没有意义。</h5>`;
            }
            if ((theta1 - theta2) % 180 == 0) { // Parallel line
                cw("#result").html += `<h2 style="color: var(--red);">无法找到要塞坐标，因为两条直线平行。</h2><h5 style="color: var(--red);">这通常是人为操作的误差造成的，请再试一次。</h5>`;
            } else {
                const dir1 = (-(x2 - x1) * Math.sin(theta2) + (z2 - z1) * Math.cos(theta2)) / Math.sin(theta1 - theta2);
                const dir2 = ((z2 - z1) * Math.cos(theta1) - (x2 - x1) * Math.sin(theta1)) / Math.sin(theta1 - theta2);
                if (dir1 < 0 || dir2 < 0) { // Wrong direction
                    cw("#result").html += `<h2 style="color: var(--red);">无法找到要塞坐标，因为两次射线方向指向不同的要塞。</h2><h5 style="color: var(--red);">这说明你的两次投掷位置间隔过远，导致定位到了不同的要塞；或者距离要塞过远，导致人为误差过大。请缩短投掷间隔并再试一次。</h5>`;
                } else {
                    const [A, B, C, D, E, F] = [eq1[0], eq1[1], eq1[2], eq2[0], eq2[1], eq2[2]];
                    
                    const strongholdX = (B * F - C * E) / (A * E - B * D);
                    const strongholdZ = (C * D - A * F) / (A * E - B * D);
                    
                    log({ strongholdX, strongholdZ });

                    // Distance to origin (stronghold)
                    const dStrongholdOrigin = Math.sqrt(strongholdX ** 2 + strongholdZ ** 2);

                    // Distances to player
                    const dTwoPos = Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);
                    const dPlayer = Math.sqrt((x2 - strongholdX) ** 2 + (z2 - strongholdZ) ** 2);

                    log({ dTwoPos, dPlayer });

                    // Stronghold Rings
                    const [toRingDistance, ringOrder, strongholdCount, innerBorder, outerBorder] = getRing(dStrongholdOrigin.keep(0));

                    // Reliability
                    const reliability = getReliability(dTwoPos, dPlayer, toRingDistance, r1, r2);
                    const color = reliability > 0.9 ? "--darkGreen" : reliability > 0.8 ? "--green" : reliability > 0.6 ? "--yellow" : reliability > 0.4 ? "--orange" : "--red";

                    cw("#result").html += `<h4>根据三角定位，此要塞的坐标为:</h4><h2 style="color: var(${color})">(${strongholdX.keep(0)}, y, ${strongholdZ.keep(0)})</h2><p>预估可信度: <strong style="color: var(${color})">${(reliability * 100).keep(1)}%</strong><br />传送到此位置: /tp @s ${strongholdX.keep(0)} ~ ${strongholdZ.keep(0)}<br />定位最近的要塞: /locate structure minecraft:stronghold</p>`;

                    if (toRingDistance > 0) {
                        cw("#result").html += `<br /><p>此要塞<strong style="color: var(--red);">不位于任何一个要塞分布环内</strong>，距离最近环 <strong style="color: var(--red);">${toRingDistance}</strong> 格。如果你正在游玩的是 Java 1.9 版及以上，这意味着<strong style="color: var(--red);">要塞定位错误或误差过大</strong>。<br />此要塞最靠近<strong style="color: var(--orange);">第 ${ringOrder} 个要塞分布环</strong>，一共有 <span style="color: var(--orange);">${strongholdCount}</span> 座要塞分布在此环内。<br />此环范围为距离世界原点 <span style="color: var(--red);">${innerBorder} ~ ${outerBorder}</span> 格范围，而定位到的要塞距离世界原点 <span style="color: var(--red);">${dStrongholdOrigin.keep(0)}</span> 格。</p>`;
                    } else {
                        cw("#result").html += `<br /><p>此要塞位于<strong style="color: var(--green);">第 ${ringOrder} 个要塞分布环</strong>内，一共有 <span style="color: var(--green);">${strongholdCount}</span> 座要塞分布在此环内。<br />此环范围为距离世界原点 <span style="color: var(--green);">${innerBorder} ~ ${outerBorder}</span> 格范围，而定位到的要塞距离世界原点 <span style="color: var(--green);">${dStrongholdOrigin.keep(0)}</span> 格。</p>`;
                    }
                    
                    if (dTwoPos < 20) {
                        cw("#result").html += `<p>你的两次投掷位置间隔 <strong style="color: var(--red);">${dTwoPos.keep(0)}</strong> 格。<strong style="color: var(--red);">间隔过近</strong>可能会导致两次投掷指向的方向夹角过小，进而导致<strong style="color: var(--red);">误差增大</strong>。建议控制两次投掷间隔在 <strong style="color: var(--orange);">20 ~ 200 格内</strong>。</p>`;
                    } else if (dTwoPos <= 200) {
                        cw("#result").html += `<p>你的两次投掷位置间隔 <strong style="color: var(--green);">${dTwoPos.keep(0)}</strong> 格。通常认为此间隔是合适的，可控制误差在合理范围内。</p>`;
                    } else if (dTwoPos <= 1000) {
                        cw("#result").html += `<p>你的两次投掷位置间隔 <strong style="color: var(--orange);">${dTwoPos.keep(0)}</strong> 格。<strong style="color: var(--orange);">间隔过远</strong>可能会导致两次投掷<strong style="color: var(--red);">指向不同的要塞</strong>，进而指向错误的位置。建议控制两次投掷间隔在 <strong style="color: var(--orange);">20 ~ 200 格内</strong>。</p>`;
                    } else {
                        cw("#result").html += `<p>你的两次投掷位置间隔 <strong style="color: var(--red);">${dTwoPos.keep(0)}</strong> 格。两次投掷的<strong style="color: var(--red);">间隔十分大</strong>，这导致两次投掷<strong style="color: var(--red);">极有可能指向不同的要塞</strong>。建议控制两次投掷间隔在 <strong style="color: var(--orange);">20 ~ 200 格内</strong>。</p>`;
                    }

                    if (dPlayer <= 1000) {
                        cw("#result").html += `<p>此要塞距离你 <strong style="color: var(--green);">${dPlayer.keep(0)}</strong> 格。由于此要塞<strong style="color: var(--green);">相对较近</strong>，你可以直接从此位置挖掘，一般情况下会到达要塞的旋转楼梯处。</p>`;
                    } else {
                        cw("#result").html += `<p>此要塞距离你 <strong style="color: var(--orange);">${dPlayer.keep(0)}</strong> 格。由于此要塞<strong style="color: var(--orange);">相对较远</strong>，建议到达该位置后再次进行一次定位。</p>`;
                    }
                }
            }
        }

        function getRing(d) {
            const border = [1280, 2816, 4352, 5888, 7424, 8960, 10496, 13032, 13568, 15104, 16640, 18176, 19712, 21248, 22784, 24320];
            if (d.range(border[0], border[1])) { return [0, 1, 3, border[0], border[1]]; }
            if (d.range(border[2], border[3])) { return [0, 2, 6, border[2], border[3]]; }
            if (d.range(border[4], border[5])) { return [0, 3, 10, border[4], border[5]]; }
            if (d.range(border[6], border[7])) { return [0, 4, 15, border[6], border[7]]; }
            if (d.range(border[8], border[9])) { return [0, 5, 21, border[8], border[9]]; }
            if (d.range(border[10], border[11])) { return [0, 6, 28, border[10], border[11]]; }
            if (d.range(border[12], border[13])) { return [0, 7, 36, border[12], border[13]]; }
            if (d.range(border[14], border[15])) { return [0, 8, 9, border[14], border[15]]; }

            const dR1Inner = Math.abs(d - border[0]);
            const dR1Outer = Math.abs(d - border[1]);
            const dR2Inner = Math.abs(d - border[2]);
            const dR2Outer = Math.abs(d - border[3]);
            const dR3Inner = Math.abs(d - border[4]);
            const dR3Outer = Math.abs(d - border[5]);
            const dR4Inner = Math.abs(d - border[6]);
            const dR4Outer = Math.abs(d - border[7]);
            const dR5Inner = Math.abs(d - border[8]);
            const dR5Outer = Math.abs(d - border[9]);
            const dR6Inner = Math.abs(d - border[10]);
            const dR6Outer = Math.abs(d - border[11]);
            const dR7Inner = Math.abs(d - border[12]);
            const dR7Outer = Math.abs(d - border[13]);
            const dR8Inner = Math.abs(d - border[14]);
            const dR8Outer = Math.abs(d - border[15]);

            const dMin = Math.min(dR1Inner, dR1Outer, dR2Inner, dR2Outer, dR3Inner, dR3Outer, dR4Inner, dR4Outer, dR5Inner, dR5Outer, dR6Inner, dR6Outer, dR7Inner, dR7Outer, dR8Inner, dR8Outer);
            const dArr = [dR1Inner, dR1Outer, dR2Inner, dR2Outer, dR3Inner, dR3Outer, dR4Inner, dR4Outer, dR5Inner, dR5Outer, dR6Inner, dR6Outer, dR7Inner, dR7Outer, dR8Inner, dR8Outer];
            const dMinPos = dArr.indexOf(dMin);

            if (dMinPos.range(0, 1)) { return [Math.max(dMin, 1), 1, 3, border[0], border[1]]; }
            if (dMinPos.range(2, 3)) { return [Math.max(dMin, 1), 2, 6, border[2], border[3]]; }
            if (dMinPos.range(4, 5)) { return [Math.max(dMin, 1), 3, 10, border[4], border[5]]; }
            if (dMinPos.range(6, 7)) { return [Math.max(dMin, 1), 4, 15, border[6], border[7]]; }
            if (dMinPos.range(8, 9)) { return [Math.max(dMin, 1), 5, 21, border[8], border[9]]; }
            if (dMinPos.range(10, 11)) { return [Math.max(dMin, 1), 6, 28, border[10], border[11]]; }
            if (dMinPos.range(12, 13)) { return [Math.max(dMin, 1), 7, 36, border[12], border[13]]; }
            if (dMinPos.range(14, 15)) { return [Math.max(dMin, 1), 8, 9, border[14], border[15]]; }
        }

        function getReliability(dTwoPos, dPlayer, toRingDistance, r1, r2) {
            let reliability = 1.1;

            if (dTwoPos < 20) {
                reliability *= dTwoPos.percentage(0, 20).transit(0.6, 0.97);
            } else if (dTwoPos < 60) {
                reliability *= dTwoPos.percentage(20, 60).transit(0.97, 1);
            } else if (dTwoPos < 200) {
                reliability *= dTwoPos.percentage(60, 200).transit(1, 0.95);
            } else if (dTwoPos < 1000) {
                reliability *= dTwoPos.percentage(200, 1000).transit(0.95, 0.5);
            } else if (dTwoPos < 1500) {
                reliability *= dTwoPos.percentage(1000, 1500).transit(0.5, 0.1);
            } else {
                reliability *= dTwoPos.percentage(1500, 2000).transit(0.1, 0.01);
            }

            if (dPlayer < 500) {
                reliability *= dPlayer.percentage(0, 500).transit(1, 0.98);
            } else if (dPlayer < 1000) {
                reliability *= dPlayer.percentage(500, 1000).transit(0.98, 0.65);
            } else if (dPlayer < 2000) {
                reliability *= dPlayer.percentage(1000, 2000).transit(0.65, 0.2);
            } else {
                reliability *= dPlayer.percentage(2000, 3000).transit(0.2, 0.02);
            }

            // [deprecated] Angle modifier
            // [deprecated] const deltaR = Math.abs((r1 - r2) % 90);
            // [deprecated] if (deltaR > 15) {
            // [deprecated]     reliability *= 1;
            // [deprecated] } else if (deltaR > 10) {
            // [deprecated]     reliability *= deltaR.percentage(10, 15).transit(0.95, 1);
            // [deprecated] } else if (deltaR > 5) {
            // [deprecated]     reliability *= deltaR.percentage(5, 10).transit(0.7, 0.95);
            // [deprecated] } else if (deltaR > 2) {
            // [deprecated]     reliability *= deltaR.percentage(2, 5).transit(0.5, 0.7);
            // [deprecated] } else {
            // [deprecated]     reliability *= deltaR.percentage(0, 2).transit(0, 0.5);
            // [deprecated] }

            if (toRingDistance == 0) {
                reliability *= 1;
            } else if (toRingDistance < 100) {
                reliability *= toRingDistance.percentage(1, 100).transit(0.9, 0.2);
            } else if (toRingDistance < 200) {
                reliability *= toRingDistance.percentage(1, 100).transit(0.2, 0.02);
            } else {
                reliability *= 0;
            }
            log({ reliability });

            return reliability.toRange(0, 1);
        }
    </script>
</div></body>

</html>